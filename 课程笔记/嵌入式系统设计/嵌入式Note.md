## 一、不考

## 二、ARM 体系结构

> 体系结构概述：1~4

- **ARM9TDMI含义：**
	T：支持高密度16位的Thumb指令集； 
	D：支持片上Debug（有JTAG接口）；
	M：内嵌硬件乘法器（Multiplier）；
	I： 嵌入式ICE，支持片上断点和调试点。

### （1）体系结构
#### 1、RISC
- RISC集特点（简答题）
	![[Pasted image 20240604101343.png]]
	注：ARM没有超标量和超流水线
#### 2、THUMB
>THUMB16位是32位的一个子集

优点：代码尺寸小 ( up to 40 % compression)，提高代码密度，简化设计，功耗更低
缺点：编码少；存储器32位时，指令条数多，执行时间长

- 状态转换
	- 通过BX指令(带状态切换的分支指令）在ARM状态和Thumb状态之间切换
	- 一旦进入异常处理（(IRQ, FIQ, RESET, UNDEF, ABORT, SWI），也进入ARM状态。
	BX是跳转指令。执行ARM指令阶段，如果想执行一段Thumb指令，则需要跳转到Thumb指令,BX指令中的Label指示Thumb指令地址。
	为了能从ARM态转为Thumb态，需要将CPSR寄存器中T标志置位，实现方法是将R0的值最后一位变为1，这样执行BX指令则导致转为Thumb态。
	假设Label地址处存放的是Thumb指令，因为是16位对齐，则Label（地址）的最低位一定为0，加1后R0最低位一定为1，则执行跳转“BX R0”切换到Thumb状态，执行Thumb指令就是当存放操作数的寄存器末位为1，则执行将切换到Thumb状态
	![[Pasted image 20240604102551.png]]
	![[Pasted image 20240604102604.png]]
#### 3、流水线
ARM7（3级、冯诺依曼架构）和ARM9（5级、哈佛架构），执行操作都在第3级，对于正在执行的指令，**当前PC = 指令地址 + 8**

#### 4、哈佛结构
- ARM9哈佛结构的特点及为什么这样做
	![[Pasted image 20240604103424.png]]
	Cache是一个通用目的的加速器，他会加速你的所有代码，但内容不断变化，存在不可预测等问题。
	TCM只会放有意加入的代码，这些代码固定不变，不会被替换，一般放某些关键代码（如中断处理函数）。
	Cache是一个通用目的解决方案，TCM在某些特殊情况下是非常有用的

	由于独立的指令和数据Cache存在，哈佛结构需要有**独立的指令总线和数据总线**

#### 5、存储器管理（不考）
- **无保护**模式：没有存储器的硬件保护，只能提供非常有限的灵活性。通常用于小的、简单的嵌入式系统，不要求存储器保护；
- 提供**有限保护**的存储器保护单元（MPU）：MPU使用一个只用到少量存储区域的简单系统，这些区域由一组特殊的协处理器寄存器控制，每一个区域定义了专门的访问权限。适用于要求有存储器保护但没有复杂存储器系统映射的系统；
- 提供**全面保护**的存储器管理单元（MMU）：MMU使用一组转化表，以提供精细的存储器控制。这些表保存在主存里，并且提供虚拟地址与物理地址的映射和访问权限。MMU适用于支持多任务的复杂操作系统平台。
	ARM的虚拟存储（只有分页机制）及存储保护
### （2）编程模型
CPSR ： 程序状态寄存器
- 两种操作状态
	ARM - 32-bit, 按字排列的ARM指令集
	Thumb -16-bit, 按半字排列的Thumb指令集

> [!NOTE] BX指令切换
> BX是带状态切换的分支指令。执行ARM指令阶段，如果想执行一段Thumb指令，则需要跳转到Thumb指令,BX指令中的Label指示Thumb指令地址。
> 对于BX指令，若Rm最低位为1，则跳转时CPSR标志位T置为1，目标地址解释为Thumb指令集代码，若为0，则标志位复位，解释为ARM指令。

- 存储器模式
	- 字编址和字节编址
	- 小端（低地址低字节）和大端（低地址高字节）地址
		ARM9默认小端，也可配置BIGEND接高电平
		![[Pasted image 20240613114110.png]]
- 七种基本工作模式
	![[Pasted image 20240604103829.png]]
	
> [!NOTE] Title
> 1、之所以划分模式，是为了中断程序的现场保护——各自使用不同的通用寄存器，简化现场保护的实现。
其中大多数情况执行在user模式，当需要执行特殊操作，需要特权，则进入sys模式，一般是操作系统用；其它5种是出现特殊情况则需要进入的模式。概念上它们都是组成原理里说到的中断，比如SWI是软中断，所以SVC是进入软中断
2、Abort:当程序试图读或者写一个不合法的内存地址时发生（没有权限访问或者地址不存在)，一般在地址映射设置错误时发生
3、FIQ与IRQ的区分：S3C2440X向ARM内核提出中断请求时，根据中断模式寄存器INTMOD的相应位决定是IRQ或FIQ请求
4、为什么FIQ比IRQ快？
(1、ARM的FIQ模式提供了更多的banked寄存器，r8到r14还有SPSR，而IRQ模式就没有那么多，R8,R9,R10,R11,R12对应的banked的寄存器就没有，这就意味着在ARM的IRQ模式下，中断处理程序自己要保存**R8到R12**这几个寄存器，然后退出中断处理时程序要恢复这几个寄存器，而FIQ模式由于这几个寄存器都有banked寄存器，模式切换时CPU**自动保存这些值到banked寄存器**，退出FIQ模式时自动恢复，所以这个过程FIQ比IRQ快
(2、FIQ的中断向量在向量表**最后**，**省去了一个跳转指令**，快。
(3、FIQ比IRQ有**更高优先级**，如果FIQ和IRQ同时产生，那么FIQ先处理

	![[Pasted image 20240604103849.png]]

- 寄存器
	![[Pasted image 20240613141956.png]]
	- R13,R14分别是堆栈指针 (SP) 、链接寄存器 (LR，中断或异常时备份PC的值)。所以各模式有自己的堆栈，并用不同的寄存器保存断点
	- R15：PC
	- CPSR：程序状态寄存器（保存当前状态）
	- SPSR：程序状态保存寄存器（保存中断前的CPSR状态，故SYS和User模式没有该寄存器）
	- 在Thumb方式下可直接访问R0-R7，PC，SP，CPSR，SPSR
	- 在ARM方式下R15的位[1:0]为0，使用[31:2]作为 PC
	- 在Thumb方式下R15的位[0]为0，使用[31:1]作为 PC
	- CPSR访问权限
		- 除User外均允许对CPSR完全读写访问
		- User允许CPSR控制域读访问和标志域的读写访问

### （3）异常
- 7种异常类型
	![[Pasted image 20240613151331.png]]
	![[Pasted image 20240613151726.png]]
	中断源显然不止7个，外部中断源可以有很多个

- 异常响应流程
	![[Pasted image 20240604104201.png]]
	PC-4：保存下一条指令的地址，中断均等待当前指令执行完毕再处理。（DABT除外，需要保存PC-8，中断响应结束后重新执行当前指令）
	![[Pasted image 20240604104409.png]]

----
## 三、指令系统
#### 1、指令集特点
- ARM指令为定长指令，可以为32bitARM，亦可以16bitThumb
- ARM9TDMI支持3种数据类型
- RISC为Load-store结构，只对寄存器数据处理，只有Load和store存取存储器指令。

#### 2、指令集语法规则
- 典型ARM指令指令格式：
$$
<opcode>{< cond>}{S}  <Rd>, {<Rn>} {,<Operand2>}
$$
	![[Pasted image 20240613155502.png]]

- 指令集第二操作数
	>两种，共占12位

	- 立即数型
		![[Pasted image 20240604105539.png]]
		重点：8位、偶数位、右移`2*bit[7:0]`
		例如：
		- `MOV R4, #0x8000000A`，其中的立即数#0x8000000A是由8位的0xA8循环右移0x2位得到。因此机器码中为：2|A8
		- `ADD r3, r7, #1020`,十进制数1020是0x3FC=0…00**11 1111 11**00，是0xFF循环右移30位后生成的32位立即数,所以#1020合法。因而在该指令的机器码中，#1020表示为FFF
		- 将0x7F02送给R3，`MOV R3，#0x7F02`为错误表示，修改方法有两种：
			- `MOV R3，#0x7F00 (C7F); ORR R3，R3，#2 ;`
			- 使用伪指令 `LDR R1，=0X7F02 ; MOV R3，R1`
		注意：0x表示十六进制，十进制0d或省略，二进制0b。使用伪指令LDR时，汇编器实际开辟存储单元（DCD，类似于x86的DD），就是文字池，literal pool，然后在机器指令中给出单元地址，其与LDR指令不同。
	
	- 寄存器移位型
		`Rm,<shift>`
		shift:移位类型 + 位数n(0 <= n <= 31)
		类型：
			LSL，LSR:逻辑左、右移位，全部补0
			ASR：算术右移，符号位不变
			ROR：循环右移，低位移出填入高位
			RRX：带进位循环右移1位，31位用原进位填入，如果指定后缀“S”，则将Rm原值的位[0]移到进位标志。
		例如：`ADD  R0, R0, R0, LSL #2`执行结果为R0 = 5 \* R0

- **寻址方式**
	ARM处理器具有8种基本寻址方式

	（1）立即寻址
		只能第二操作数使用，且需满足循环右移规则
	（2）寄存器寻址
		操作数的值在寄存器中，指令中指出的是寄存器编号，指令执行时直接取出寄存器中的值来操作
	（3）寄存器移位寻址
		ARM指令集特有，见上文寄存器移位型第二操作数
	（4）寄存器间接寻址
		寄存器中存放存储器地址，需要对存储器进行访问，由LDR、STR、SWP使用
	（5）基址变址寻址
		![[Pasted image 20240604111302.png]]
		四种形式
		![[Pasted image 20240604111357.png]]
		注意：
			寄存器带 ！需要指令执行后修改该寄存器的值
			
	（6）多寄存器寻址
		主要由LDM、STM使用
		格式：`OP{<cond>}<mode> Rn{!} reglist{^}`
		![[Pasted image 20240614171624.png]]
		例子：
			![[Pasted image 20240613175138.png]]
		注意：多寄存器指令执行顺序与列表次序无关，而是按照寄存器本身大小顺序从小到大。连续的寄存器可用-连接。
	（7）堆栈寻址
		堆栈指针SP
		![[Pasted image 20240604111628.png]]
		![[Pasted image 20240604112134.png]]
		![[Pasted image 20240613181218.png]]
		注意：满递增每次出栈时需要地址减4，堆栈操作均使用STM、LDM块传送指令实现，无pop、push等指令
		注意：出入栈次序仍然与列表顺序、堆栈类型无关，小寄存器放在低地址。且默认均为小端方式
		
	（8）相对寻址
		![[Pasted image 20240604113203.png]]
		B指令执行时：偏移地址扩展到32位后再算术左移2位（每条指令地址最低2位为0）加到PC上。
		![[IMG_20240604_111656.jpg]]![[IMG_20240604_112507.jpg]]![[IMG_20240604_112924.jpg]]![[IMG_20240604_113604.jpg]]
		B指令，fffffe为24位偏移量，补码表示-2，当前PC为该指令实际PC+8，24位偏移量右移8位（补2个0）后为-8，指令执行后跳转到当前PC-8，即该指令地址，实现死循环。
- 常用指令
	![[Pasted image 20240611100515.png]]
	- 分支指令：
		- B：B{cond} label = PC <- PC + 偏移地址
		- BL：BL{cond} label = LR <- PC - 4 带链接分支，为子程序调用指令，可实现子程序返回（即跳转到指定位置执行后返回原程序的下一条继续执行）
		- BX：BX{cond} Rm = PC <- PC + Rm 带可选择地交换指令集分支指令，**采用寄存器间接寻址**，可实现ARM和Thumb态的切换
	- 长跳转：直接向PC写入目标地址值，实现任意跳转
	- Load/Store：LDR、STR、LDM、STM、SWP(寄存器和存储器交换字节或字，读写为原子操作)
	- 数据处理指令
		![[Pasted image 20240613204654.png]]
		![[Pasted image 20240613204737.png]]
	- 状态切换2
		- MRS：读状态寄存器；MSR：写状态寄存器
		![[Pasted image 20240613205243.png]]
		eg: `MSR CPSR_c, #0xD3`；即CPSR0-7位赋值为该立即数，切换到管理模式
		需要注意ARM和Thumb的切换必须通过BX完成，只有它会打断流水线状态，实现处理器状态切换。
- 常用伪指令
	![[Pasted image 20240611100538.png]]
	- 数据变量定义
		- GBL：全局符号，A-算术，L-逻辑，S-字符串
		- SPACE：申请连续字节单元，不赋初值
		- DCB：申请连续字节单元并初始化
		- DCD：申请连续字单元并初始化
		- MAP：结构化内存表首地址
		- FIELD：结构化内存表数据域，与MAP合用定义结构体
	- 段定义
		- AREA 段 属性，属性......
		- CODE、DATA、READONLY、READWRITE、ALIGN（=n，表示后续指令为2的n次方字节对齐，n表示地址最后n位为0）、NOINIT
	- ARM伪指令（汇编时被等效指令代替）
		- ADR：将标号知识的偏移地址转换为绝对地址存到寄存器中。小范围寻址（地址范围取决于地址表达式对齐量，表达式只有8位，字节对齐为-255-255，字对齐为-1024-1024）
		- ADRL：中等范围寻址，转换为两个ADD或SUB指令（范围-64k-64k）
		- LDR：常数未超过MOV或MVN，用之，否则放入文字池并用带相对偏移量的LDR指令读出常量。常用于加载I/O接口的寄存器地址，实现控制操作。
		- NOP：空操作，可用于延时。
		- LTORG：表示一个数据缓冲池的开始
		- CODE32/CODE16：标识ARM或者Thumb指令，本身不进行切换操作
		eg:数据从src复制到dst
			![[Pasted image 20240614094054.png]]
			
## 四、ARM编程
- 程序到可执行过程：
	汇编程序->汇编->目标文件->链接器->二进制文件
	链接器：负责处理程序与存储器地址相关的内容，把不同程序的不同区段链接成一个完整的区。
	！**ARM大小写敏感，不要混用，命令不允许顶格书写**
- 映像文件的组织
	一个映像文件由一个或多个域组成，每个域最多由三个输出段组成（RO、RW、ZI），包含一个或多个输入段（输入段包含代码和数据）
	![[Pasted image 20240614104043.png]]
	![[Pasted image 20240614105019.png]]

- ATPCS
	- ATPCS规范
		- 寄存器：子程序间R0-R3传参、子程序中R4-R11保存局部变量、R12临时寄存器（保存当前LR）、R13（SP）
		- ATPCS堆栈：FD（满递减）、8字节对齐
		- 参数传递：固定个数参数、可变个数参数（<= 4,用R0-R3传递，否则传入堆栈或内存，按照相反顺序入栈）
		- 结果返回：32bit int（R0）、64bit int（R0+R1）、浮点数（f0、d0、s0等）
	- 内嵌汇编：不要指定物理寄存器、程序跳转调用使用B/BL。
		- 调用汇编example：
			![[Pasted image 20240614163350.png]]
			![[Pasted image 20240614163406.png]]
	- 调用非内嵌汇编：汇编程序：**EXPORT声明**被别的程序调用、**IMPORT声明**调用的C程序。C语言：**extern**声明调用的汇编程序，C++ extern “C”，汇编程序标号可以作为C调用的函数名。
		- 互相调用
			![[Pasted image 20240614172742.png]]
			![[Pasted image 20240614172755.png]]
			注意：STMIA后R13未加！，说明其值不改变，栈顶指针仍在原来的地方。调用compare_ip时，前四个参数从R0-R3寄存器取，后四个从堆栈取，取完不修改堆栈指针。该函数执行完结果存在R0中。
			![[Pasted image 20240614172841.png]]
	- 结构体参数、指针传递：将结构体首地址作为参数传递进R0
		- example：
			![[Pasted image 20240614180352.png]]
			![[Pasted image 20240614180408.png]]
			![[Pasted image 20240614180419.png]]
			![[Pasted image 20240614180432.png]]
			![[Pasted image 20240614180446.png]]
## 五、ARM 最小系统设计

##### 存储器分类
![[Pasted image 20240603105437.png]]

##### SDRAM
- SDRAM 内部分为多个 Bank——多 Bank 结构，各 Bank 以方式工作——当一个 Bank 可能处于预充电状态，正在经历访问延迟时，另一个 Bank 可能正在进行读取。
- 因此可做到与系统时钟（133 MHz）同步，比传统 DRAM 更高的时钟速度（3 X） 

##### ARM 最小系统
- S3C2440是什么芯片？
	是以ARM920T为内核的SoC芯片，其使用16/32 bit RISC指令集，具有SDRAM控制器、NAND Flash控制器、4通道DMA、中断控制器/支持24个中断源、117个GPIO......

- S3C2440的最小系统什么含义？通常包括哪些部分的设计？各部分作用是什么？
	指为S3C2440提供最基本工作条件的必要的外围电路，通常包括：S3C2440芯片、电源/复位电路、晶振电路（时钟系统）、Flash存储器、SDRAM/SRAM存储器、JTAG接口、系统总线扩展。作用见下文

(1) ARM 微处理器芯片**S3C2440**
(2) **电源及复位电路**：为S3C2440提供1.80V工作电压，为部分外围芯片提供3.3V的工作电压
(3) **晶振电路**：为微处理器及其他电路提供工作时钟
(4) **FLASH存储器**：存放嵌入式操作系统、用户应用程序或者其他在系统掉电后需要保存的用户数据等
(5) **SRAM、SDRAM存储器**：作为系统运行时的主要区域，系统及用户数据、堆栈均位于该存储器中；
(6) **JTAG接口**：对芯片内部所有部件进行访问，通过该接口对系统进行调试、编程等
(7) **系统总线扩展**：引出地址总线、数据总线和必须的控制总线，便于用户根据自身的特定需求，扩展外围电路。

#### 最小系统设计
##### 1. 电源电路设计
S3C2440 及 RTC 模块(时钟电路)提供的电源：1.8 V/300 mA
存储器等的电源：3.3 V/ 600 mA
实现：DC-DC 转换器实现 5 V 到 3.3 V 和 5 V 到 1.8 V 的转换。
RTC 模块在外部掉电由电池供电

##### 2. 晶振电路设计
S3C2440需要外部提供时钟信号：外部晶振或者外部时钟信号（10-20MHZ）

内部时钟控制逻辑包括两个PLL（MPLL和UPLL） ，MPLL用于产生CPU的FCLK （最高400MHz），AHB总线接口的HCLK， APB总线接口的PCLK。UPLL用于产生USB模块的时钟UCLK （48MHZ）

引脚OM3、OM2选择时钟源

##### 3. 复位电路设计
复位信号 nRESET(J12)使S3C2440初始化为某个确定的状态。大多数微处理器需要外部输入这个信号
复位信号时序
![[Pasted image 20240603112904.png]]

##### 4. JTAG调试接口设计
IEEE制定的JTAG标准，主要用于芯片内部测试及对系统进行调试。
芯片内部有专门的电路测试访问接口（TAP），通过专用的JTAG测试工具对内部节点进行测试
目前大多数微处理器（ ARM、DSP、FPGA ）都支持JTAG标准

##### **5. 主存储器设计（重点）**
（1）使用两大类——RAM、ROM
- SRAM
- SDRAM （同步DRAM）->DDR、DDR2
- NOR Flash
- 外存——NAND Flash
（2）存储器组织
- 按启动方式不同，有两种组织方式
    使用NAND Flash启动——OM[1:0]=00
	使用NOR Flash启动—— OM[1:0]=01,10
- 存储空间的划分
    地址总线位数、地址如何实现划分
    统一编址
（3）NOR 和NAND
- NOR Flash
	- NOR Flash具有SRAM接口，线性寻址，按字或字节访问，主要用于**主存**。可实现片内执行。
	- NOR Flash写入和擦除速度快、稳定性高、价格高。
	- 使用NOR Flash启动，则复位时PC指向0x00， NOR Flash相当于**EPROM、EEPROM**

- NAND Flash
	- NAND Flash的读写类似硬盘，因此可独立成为**外存**，如USB盘、CF、SD和MMC存储卡等，取代磁盘。
	- NAND Flash每比特成本低，容量大，但读出速度较慢、无存储器接口。因此可从NAND Flash启动和引导系统，而在SDRAM上执 行主程序代码
	- **需要专门的控制器——集成在S3C2440中**

- 分区（Bank）
	- 两种方式存储器空间均为1G Byte（0X00000000-0X3FFFFFFF），剩下3G中，0x48000000-0x5FFFFFFF（1.5G）为SFR，即特殊类型寄存器地址空间，其余地址均未使用。
	- 本来需要32根地址引脚，但访存最高两位恒为0；再利用其次的高3位地址产生8根片选信号nGCS [ 0 : 7 ]，相当于将存储空间划分为8个Bank，每根片选选择每个Bank。因此只有27根地址ADDR [ 0 : 26]
	- 每个Bank可实现**ROM或SRAM**，Bank6、7还可实现**SDRAM**。
	- Bank7-1可按总线宽度**8/16/32位**访问， Bank0只能按**16/32位**访问
	- 在使用**NAND Flash**启动时， Bank0 设计为4KB的SRAM，复位时，将NAND Flash的前4KB(引导代码)被送入Steppingstone，在 Steppingstone中执行。这称为自引导模式
	- NAND Flash控制器中已经设置了Steppingstone
	- S3C2440的存储空间为什么按Bank组织？（GPT答案）
		- 灵活性：不同的Bank可以配置为使用不同类型的存储技术，允许系统设计者根据应用需求选择最合适的存储解决方案。
		- 扩展性：通过增加或减少Bank的数量，可以容易地扩展或缩减系统的存储容量。
		- 兼容性：不同的Bank可以支持不同的存储接口标准，使得S3C2440能够与多种存储设备兼容。
		- 性能优化：通过合理分配存储资源到不同的Bank，可以优化存储访问的性能，例如将频繁访问的数据放在更快的存储介质上。
		- 电源管理：不同的Bank可能有不同的电源管理需求，按Bank组织可以更容易地实现精细的电源控制。
		- 错误隔离：如果某个Bank出现问题，它不会影响到其他Bank，从而提高了系统的可靠性。
	- nGCS[0:7]、 nWBE[3:0]信号的作用、如何产生的？为什么连接存储器时只有27根地址ADDR[0:26]？
		- nGCS作为8根片选信号用于选择每个Bank，从32根地址引脚中去除最高两位0，利用次高3位经过3-8译码器产生8位片选信号。剩余27根作为地址线ADDR
		- WBE信号作为选体信号，用于实现按字和按字节编址并访问。
（4）如何按字节/按字同时访问？
- STR R1, [R0]		;R0中放字地址
- STRH R1, [R0]		;R0中放半字地址
- STRB R1, [R0]		;R0中放字节地址    
**CPU出来只有30根，另两个被nWBE[3:0]/nBE[3:0]取代，CPU根据指令中地址、指令访存字长将最低2位地址转换为字节使能信号。**
- nWBE[3:0]如何产生？
    -  STR、地址是字地址，则4个都有效
    - STRH、STRB，则根据地址最低两位产生
    - 写操作时选体；读操作时WBE无效，所有读存储器指令均产生有效OE信号
- Example：
	- (unsigned char \*) 0x300000**00** = 0x78; 
		  只有nWBE0信号有效，访问一个字节
	* (unsigned char \*) 0x300000**01** = 0x78; 
		  只有nWBE1信号有效，访问一个字节
	* (unsigned short \*)0x300000**00** = 0x1978;
		nWBE1、0信号有效，访问两个字节，地址最低位必须是0，因为按16位对齐，否则会使CPU异常
	* (unsigned int \*)0x300000**00** = 0x19783456;
		 nWBE3到0信号均有效，访问一个字，地址最低两位必须是0，因为按32位对齐，否则会使CPU异常
	- LDR R0, =0x30000000
		   MOV R1, 0x78
		   STRB R1, [R0]  ;只有nWBE0信号有效，访问一个字节 
	- LDR R0, =0x30000001
		   MOV R1, 0x78
		   STRB R1, [R0]  ;只有nWBE1信号有效，访问一个字节 
	- LDR R0, =0x30000000
		   MOV R1, 0x1978
		   STRH R1, [R0]  ; nWBE1、0信号有效，访问两个字节
- S3C2440总线有关引脚
	- DATA[0:31]：
	- ADDR[0:26]：概念上相当于32根地址线，为什么有ADDR[0:1]？
	- nGCS[0:7]——分区（Bank）信号，相当于片选信号，根据高5位地址产生，设计的存储器可能存储单元是8位的，则需要ADDR[0:1]
	- nWE、nOE：指示读/写周期
	- nWBE/nBE [3:0]： Write Byte Enable/ Byte Enable ，即（写）选体信号。实现bus宽度选择，根据指令strB、strH、str产生
> nWBE与nBE共用一组引脚，可以通过对相关寄存器设置来进行功能选择。可以用做nWBE，也可用作nBE。
> 作为nWBE[3:0]：写操作时选体；读操作无效，以字为单位读，由CPU选择。
> 作为nBE[3:0]：情况类似
> nBE[3:0] =  nWBE[3:0] & nOE      按位与

![[Pasted image 20240614213823.png]]
![[Pasted image 20240614214153.png]]

（5）SFR（特殊功能寄存器）
- S3C2440内部封装了多个接口， SFR实际是I/O端口
>内部IO接口的IO端口已经编址，48000000——5FFFFFFF.
如果外部扩充IO接口，如同存储器一样


（6）存储器初始化
- 需要对每个Bank连接存储器类型、宽度等信息进行说明；
- 如果Bank6、7连接SDRAM，还需要说明数据传输方式、刷新方式和刷新周期、信号保持时间等进行配置；
上式的说明和配置是通过对S3C2440X的13个特殊功能寄存器配置完成的，这13个寄存器地址是连续的。
- 总线宽度及等待控制寄存器BWSCON （1个）
	设置Bank0-7的位宽度及等待状态控制，每个Bank用4位，下表显示Bank7的情况
	![[Pasted image 20240603160400.png]]
- Bank控制寄存器BANKCON0-7（8个）
	设置Bank0-7的存储器类型、行列选通信号延时及列地址位数
	![[Pasted image 20240603160513.png]]
- 刷新控制寄存器BREFRESH （1个）
	设置对SDRAM刷新参数
	![[Pasted image 20240603160536.png]]
- Bank6、7容量寄存器BANKSIZE （1个）
	设置各Bank容量
	![[Pasted image 20240603161009.png]]
- SDRAM模式设置寄存器MRSRB6、7 （2个）
![[Pasted image 20240603161042.png]]


## 六、ARM系统设计

>最小系统硬件完成，还需考虑：
1、内部硬件资源（GPIO、中断系统、Watch Dog、UART、DMA等）如何使用；
2、各种硬件（时钟、主存、其它硬件）初始化，中断向量、堆栈、工作模式的设置，中断程序编写
3、最终形成BootLoader——程序框架

#### 1、系统时钟
- 两个PLL的输入信号是外部晶振或者外部时钟信号——10到20M，由引脚OM3、OM2选择
- S3C2440X具有两个PLL（MPLL和UPLL） ，MPLL产生FCLK，HCLK，PCLK。UPLL产生USB模块的UCLK时钟信号（48MHZ） 
- OM[3:2]=00时，MPLL和UPLL的时钟均选择外部石英振荡器；
##### 上电复位后对系统时钟的设置
- PLL相当于I/O接口，其中有控制端口，可进行设置
- 对PLL的设置：
    （1）先设置UPLLCON寄存器，输出UCLK
    （2）等7个NOP后再设置MPLLCON寄存器，输出FCLK
    （3）设置CLKDIVN寄存器，决定FCLK:HCLK:PCLK的比值

#### 2、电源管理
- 为了高效、低功耗，通过软件控制电源管理模块，使S3C2440X运行在4种模式：
	（1）正常模式(Normal)
	（2）慢时钟模式(Slow)
	（3）空闲模式(Idle)
	（4）休眠模式(Sleep)

#### 3、IO接口
总线与I/O设备的接口部件，I/O系统硬件的组成部分
![[Pasted image 20240603162602.png]]
##### （1）IO接口作用
- 通过数据缓冲实现CPU与I/O间的速度匹配；（显卡中的VRAM）
- 通过串—并（或并—串）转换电路实现CPU与I/O之间的数据格式转换；（显卡中的移位寄存器）
- 通过电平匹配实现CPU与I/O之间的电气转换；（RS-232）
- 通过接收与传达控制命令实现CPU对I/O接口的控制；
- CPU可查询I/O状态；
- 通过设备选择电路向CPU提供I/O寻址功能（统一、独立编址）。
##### （2）IO接口解决问题
- I/O（端口）编址问题：确定 I/O端口地址
        统一、独立编址
- I/O控制方式
	无条件传送
	程序查询方式
	I/O中断方式
	DMA方式

##### （3）GPIO
###### 1.介绍
- GPIO，General-Purpose IO ports，通用IO端口（这些端口可存放任何信息，包括数据信息）
- 实际指一种I/O接口，内部有端口，对外有一组引脚，可输入/出高低电平
- 在嵌入式系统中，经常需要控制许多结构简单的外部设备或者电路，这些设备需要CPU提供输入或输出信号，并且只要求有开/关两种状体就够了，比如LED的亮与灭。对这些设备的控制，使用传统的串口或者并口就显得比较复杂，因而使用GPIO
###### 2.S3C2440X芯片的GPIO
- S3C2440X芯片上共有117个多功能的输入/输出引脚，它们分为独立的8组GPIO：
	1个23位的输出端口（端口A）
	2个11位的输入/输出端口（端口B、H）
	4个16位的输入/输出端口（端口C、D、E、G）
	1个8位的输入/输出端口（端口F）
- 每个I/O端口均是多功能（复用）的，需要通过对应的控制寄存器进行设置。如果某个I/O引脚不用于特定功能的话，那么该引脚就可以设置为普通的输入/输出引脚。

###### 3.常用寄存器
- 控制寄存器（GPACON-GPHCON）
	在S3C2410X 中，大多数的引脚都复用，所以必须对每个引脚进行配置。端口控制寄存器（GPnCON）定义了每个引脚的功能。
- 数据寄存器（GPADAT-GPHDAT）。
	如果端口被配置成了输出端口，可以向GPnDAT的相应位写数据。如果端口被配置成了输入端口，可以从GPnDAT的相应位读出数据。
- 上拉寄存器（GPBUP-GPHUP）。
	端口上拉寄存器控制了每个端口组的上拉电阻的允许/禁止。如果某一位为0，相应的上拉电阻被允许；如果是1，相应的上拉电阻被禁止。
	如果端口的上拉电阻被允许，无论在哪种状态（INPUT、OUTPUT、DATAn、EINTn等）下，上拉电阻都起作用。
>上拉电阻
>1：加大电流，加强了驱动的能力
>2：对于OC门，将不确定的信号通过一个电阻嵌位(保持)在一个高电平上
>（不接上拉电阻：送出低电平，管子导通，则输出低；送出高电平，管子截止，则浮空。接上拉电阻：送出低电平，管子导通，则输出低；送出高电平，管子截止，则高电平。）

- 端口A寄存器（GPACON，GPADAT）
	22个引脚、只能输出、无上拉电阻
	(1) GPACON[22:0]中的某一位置位，则对应引脚为输出口，否则为某种特殊功能端口
		  GPA22	0 = Output     1 = nFCE	
		  . . . . . .
	    GPA1	0 = Output     1 = ADDR16	
		  GPA0	0 = Output     1 = ADDR0
		
	(2) GPADAT[22:0]寄存器：当端口被配置成输出时，引脚状态和相应的位状态一致

- 端口B寄存器(GPBCON,GPBDAT,GPBUP)
	11个IO引脚
	(1) GPBCON[21:0]
     GPBCON[21:20]:  00 = Input, 01 = Output
                10 = nXDREQ0, 11 = reserved
     ……
     GPBCON[1:0]: 类似

	(2) GPBDAT[10:0]  GPB共11位
     当配置成输入时，外部数据可以从对应的端口中读出；
     当配置成输出时，写入该寄存器的数据会被送到对应的引脚上；
     当端口被配置成功能脚时，此寄存器未定义

	(3) GPBUP[10:0]
     0：使能对应引脚的上拉功能
     1：对应引脚的上拉功能无效

###### 4、GPIO的应用
- 利用S3C2440X的GPF4-7四个I/O管脚控制4个LED发光二极管，使其有规律的闪烁。
- 电路连接：GPF共8位
	![[Pasted image 20240603165729.png]]
- 寄存器设置
	- 配置GPFCON寄存器，将GPF4、GPF5、GPF6、GPF7设置为输出
	- 设置GFPDAT寄存器相应位为0/1，实现点亮与熄灭
	- 对于本例来说，LED需要电流较小，GPFUP可以不用设置。

.......


#### 4、中断系统设计
##### （1）程序框架——主程序 + 中断程序
涉及：
（1）复位及SWI中断服务程序的编写
（2）中断向量表
（3）中断返回
（4）工作模式切换
